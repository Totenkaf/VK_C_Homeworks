[![.github/workflows/ci.yml](https://github.com/Totenkaf/VK_C_Homeworks/actions/workflows/ci.yml/badge.svg?branch=HW_2)](https://github.com/Totenkaf/VK_C_Homeworks/actions/workflows/ci.yml)

# VK | SEM I_Advanced C/CPP | HW_2

Вариант #11
================================================================
Усцов Артем Алексеевич. Группа ML-11.
Преподаватель: Александр Жиров

В вашем распоряжении — массив из 100 млн. чисел - отсчётов сигнала ЭКГ, полученных при частоте дискретизации f (например, f=360 Гц).
Составьте последовательный алгоритм подсчета количества R-пиков сигнала, считая, что R-пики - это локальные максимумы сигнала по модулю (они могут быть как положительной, так и отрицательной полярности), и между соседними R-пиками должно пройти как минимум R_window отсчётов (например, R_window = 115).
Распараллельте его на несколько процессов с учётом оптимизации работы с кэш-памятью.

__Требования к оформлению:__
1) параллельная реализация не должна быть осуществлена с помощью процессов, когда требуется реализация с помощью потоков (и наоборот);
2) компиляция должна происходить с флагами -Wall -Werror -Wpedantic, то есть необработанных "ворнингов" быть не должно;
3) количество потоков/процессов должно быть не захардкожено, а определяться в зависимости от возможностей системы (например, в зависимости от количества ядер процессора);
4) при разработке обеих библиотек стоит делать общий интерфейс, не раскрывая особенностей реализации;
5) библиотеки должны быть взаимозаменяемыми - конкретная реализация (последовательная/параллельная) - использоваться в зависимости от конфигурации сборки;
6) юнит-тесты должны быть реализованы для обеих реализаций (последовательной/параллельной). Покрытие тестами должно быть максимально возможным;
7) должны присутствовать стресс-тесты. Они могут быть реализованы внешним образом, запуская две разные программы - одну со статической библиотекой с последовательной реализацией, вторую - с динамической библиотекой с параллельной реализацией, и сравнивая их выводы друг с другом.
8) для организации ввода/вывода больших данных полезно работать с файлами, а в программе - предусмотреть работу с универсальными потоками входных/выходных данных (или хотя бы перенаправлять ввод/вывод на уровне их запуска)
9) если в задании сказано, что программа должна обрабатывать файлы объёмом 100 Мб – это лишь ориентир, на которых программа точно должна работать, и на котором имеет смысл делать замеры производительности и эффективности алгоритмов. Поэтому тесты на такой объём должны быть. Однако сама программа должна уметь работать с произвольными размерами входных данных
10) измерение времени должно осуществляться внешним образом, а не внутри кода библиотек. При этом необходимо делать несколько замеров и усреднять. Стоит помнить о том, что clock() в многопоточных приложениях работает не так, как ожидается.


__Помимо самой программы необходимо:__
1) разработать набор юнит-тестов, проверяющих корректную работу реализованных функций. Обеспечить максимальное покрытие исходного кода тестами;
2) оформить задачу в виде Merge Request отдельной ветки в основную ветку проекта.
Внимание: в основной ветке проекта никакого кода быть не должно!
3) развернуть CI, в рамках которого автоматизировать сборку проекта, прохождение юнит-тестов под valgrind, генерацию отчёта о покрытии кода тестами, линтера и статического анализатора исходного кода;
4) после прохождения всех проверок необходимо отправить код на ревью своему преподавателю;


__Итоги реализаций:__
1) Время работы последовательного алгоритма:
2) Время работы параллельного алгоритма:

Таким образом, можно сделать вывод, что параеллельная реализация (не) позволила осуществить ускорение работы программы (в связи с ...)